/*
 * messynavigation.c
 * authored by chris - 11/29/24
 * coded while listening to boris - pink.
 */

//desmos ref: https://www.desmos.com/calculator/vdjnon1tet
#include "messynavigation.h"


//sets the gap number to zero.
void messy_nav_init()
{
    gap_number = 0;
}

//this method finds gaps from an imaginary line (the 0-180 scan line) and a real edge. 
//it takes the current position, the coordinate of an edge, and whether the gap should be @ 0 deg or 180 deg.
gap_point_t find_gap(position *current, coord_t edge, int is_zero)
{
    //declare return value
    gap_point_t result;

    //convert position into coordinate
    coord_t bot;
    bot.x = current->x;
    bot.y = current->y;

    //
    coord_t inter;
    inter.x = edge.x;
    inter.y = (int) (edge.x * ((edge.x - bot.x) / ((-1 * edge.y) + bot.y)));

    float a = find_resultant(bot, edge);
    float b = find_resultant(bot, inter);
    float c = find_resultant(inter, edge);

    result.gap = (int) (a
            * sin(acos((pow(a, 2) + pow(b, 2) - pow(c, 2)) / (2 * a * b))));

    float b_prime = sqrt(pow(a, 2) - pow(result.gap, 2));
    result.midpt.x = bot.x
            + b_prime
                    * cos((current->deg + (is_zero ? 270 : 90))
                            * (M_PI / 180.0));
    result.midpt.y = bot.y
            + b_prime
                    * sin((current->deg + (is_zero ? 270 : 90))
                            * (M_PI / 180.0));

    return result;
}

//This method returns the increments needed to get 50 centimeters away from the current bot position, perpendicular of the 90 degree scan point.
coord_t get_increments(position *bot, coord_t dest)
{
    //used for debug.
    //char message[100];
    //holds the slope of the rotated line
    float slope;
    //calculate the slope of the perpendicular line. this is done by rotating the direct slope by 90 degrees, which is achieved by translation (x,y) to (-y,x).
    slope = ((dest.x - bot->x) * 1.0f) / ((bot->y - dest.y) * 1.0f);
    //declare return value
    coord_t result;
    //this finds the amount x one needs to increment in one direction from the center for the line generated by the slope to extend by 500 mm.
    result.x = round(500 / sqrt(1 + pow(slope, 2)));
    //plug the x into the equation to find the y increment.
    result.y = abs((int) (result.x * slope));

    //debug
//    sprintf(message, "Slope: %.5f, X inc=%d, Y inc=%d ", slope, result.x,
//            result.y);
//    uart_sendStr(message);
    //return both increments as an ordered pair.
    return result;
}

//this is a version of navigating the messy field that uses coordinate points that represent object edges for calculating gaps. This assumes that an object is constructed using 2 coordinates.
void nav_to_by_max_thirty_edge_coords(position *current, coord_t destination,
                                      int dist)
{
    //used for debug - not needed in final build.
    //char message[100];

    //declare counter variable for later and clear gaps array
    int i;
    memset(gaps, 0, sizeof(gaps));
    gap_number = 0;

    //first, need to rotate the bot so the robot has the destination at the 90 degree point of the scan.
    rotate_towards(current, destination);

    //next, perform a 180 degree scan with the shortest path at the 90 degree point.
    scan_for_objects();

    //if no obstacles are detected, we simply move forward along the easiest path.
    if (num_obstacles == 0)
    {
        move_forward_live_update(dist, current);
        return;
    }
    //if that if failed, then we have to find a new path.
    //now, we should have all of the coordinate points of the edges of objects. with this, we should be able to find potential gaps by doing some fun trig.

    //declare a intermediary coordinate.
    coord_t temp;
    //floats for pythagorean.
    float side_a, side_b, side_c;
    //iterate through all of the gaps. for n obstacles there are n+1 gaps, so use <=.
    for (i = 0; i <= num_obstacles; i += 2)
    {
        //there are special things that we need to do for the first and last object since they are gapped against the scan line.
        if (i == 0)
        {
            //check to see if the start angle is not zero.
            if (objects[num_objects - 1].start_angle != 0)
            {
                //create coordinates for generating the point along the perpendicular line
                coord_t limit;
                coord_t incr;
                //find the x and y increments to get 50 cm away from the bot, perpendicular to the 90 deg scan line.
                incr = get_increments(current, destination);
                //find the current servo position.
                coord_t servo = find_servo_pos(current);
                //find that 50 cm point relative to the servo.
                limit.x = servo.x + incr.x;
                limit.y = servo.y - incr.y;
                //the gap magnitude will be the resultant between the 50 cm extension and the first edge.
                gaps[gap_number].gap = (int) find_resultant(limit,
                                                            obstacles_arr[0]);
                //find the midpoint by getting the x and y differential and dividing by 2.
                temp.x = (int) round(
                        limit.x + (obstacles_arr[0].x - limit.x) / 2.0f);
                temp.y = (int) round(
                        limit.y + (obstacles_arr[0].y - limit.y) / 2.0f);
                //set the midpoint
                gaps[gap_number].midpt.x = temp.x;
                gaps[gap_number].midpt.y = temp.y;

                //debug; not used in final build
                //            sprintf(message, " (%d, %d) \n\r", limit.x, limit.y);
                //            uart_sendStr(message);
            }
        }
        //this case if for when we need to find the gap between the final edge and the 180 degree side extension.
        else if (i == num_obstacles)
        {
            //check to see if the end angle of the object is not 180.
            if (objects[num_objects - 1].end_angle != 180)
            {
                //create coordinates for generating the point along the perpendicular line.
                coord_t limit;
                coord_t incr;
                //find the x and y increments to get 50 cm away from the bot, perpendicular to the 90 deg scan line.
                incr = get_increments(current, destination);
                //find the current servo position.
                coord_t servo = find_servo_pos(current);
                //find that 50 cm point relative to the servo.
                limit.x = servo.x - incr.x;
                limit.y = servo.y + incr.y;
                //the gap magnitude will be the resultant between the 50 cm extension and the first edge.
                gaps[gap_number].gap = (int) find_resultant(
                        limit, obstacles_arr[i - 1]);
                //find the midpoint by getting the x and y differential and dividing by 2.      
                temp.x = (int) round(
                        limit.x + (obstacles_arr[i - 1].x - limit.x) / 2.0f);
                temp.y = (int) round(
                        limit.y + (obstacles_arr[i - 1].y - limit.y) / 2.0f);
                //set the midpoint
                gaps[gap_number].midpt.x = temp.x;
                gaps[gap_number].midpt.y = temp.y;
                //debug; not used in final build
                //            sprintf(message, " (%d, %d) \n\r", limit.x, limit.y);
                //            uart_sendStr(message);
            }
        }
        //this last case is the most frequently used and is for finding gaps between objects.
        else
        {
            //first, find the gap size through pythagorean. side_a is x, side_b is y.
            side_a = obstacles_arr[i - 1].x - obstacles_arr[i].x;
            side_b = obstacles_arr[i - 1].y - obstacles_arr[i].y;
            side_c = (int) round(sqrt(pow(side_a, 2) + pow(side_b, 2)));
            //put in the gap array
            gaps[gap_number].gap = side_c;
            //with the gap size found, need to find the midpoint by getting half of the differential and adding it to the first coordinate.
            temp.x = obstacles_arr[i - 1].x
                    + (obstacles_arr[i].x - obstacles_arr[i - 1].x) / 2.0f;
            temp.y = obstacles_arr[i - 1].y
                    + (obstacles_arr[i].y - obstacles_arr[i - 1].y) / 2.0f;
            gaps[gap_number].midpt = temp;
        }
        //increment the amount of gaps found
        gap_number++;
    }

    // debugging uart_send of gaps
//    for (i = 0; i < gap_number; i++)
//    {
//        sprintf(message, "Size: %d, midpoint: (%d, %d), Resultant: %f\n\r",
//                gaps[i].gap, gaps[i].midpt.x, gaps[i].midpt.y,
//                (find_resultant(gaps[i].midpt, destination)));
//        uart_sendStr(message);
//    }

    //now that we have all the gaps, we need to find the gap that is closest to our destination.
    //this is simple; we just need to find the gap whose midpoint generates the closest resultant to the ideal vector.

    //initialize the temp coord with the current pos
    temp.x = current->x;
    temp.y = current->y;
    //initialize the best resultant with a dummy value.
    float best_resultant = 9999999;
    //declare best coordinate and a temp float.
    coord_t best;
    float tempf;
    //iterate through the gaps
    for (i = 0; i < gap_number; i++)
    {
        //find the resultant between the midpoint and the destination.
        tempf = find_resultant(gaps[i].midpt, destination);
        //if the resultant between the current midpoint and destination is less than the best resultant, and the gap is adequate, and the midpoint won't make the bot drift out of bounds, then make it the best.
        if (tempf < best_resultant)
        {
            if (gaps[i].gap >= 310 && gaps[i].midpt.x > 175
                    && gaps[i].midpt.y > 175 && gaps[i].midpt.x < (GRID_X - 175)
                    && gaps[i].midpt.y < (GRID_Y - 175))
            {
                best_resultant = tempf;
                best.x = gaps[i].midpt.x;
                best.y = gaps[i].midpt.y;
            }

        }
    }
    //if the best resultant is stil the dummy value, then there are no paths.
    if (best_resultant == 9999999)
    {
      //  uart_sendStr("No paths found!\n\r");
        prepMarioSound();
        playSong(0);
        return;
    }
    //used for debug; not used in final build
    //sprintf(message, "Moving to (%d, %d)\n\r", best.x, best.y);
    //  uart_sendStr(message);

    // rotate toward destination
    rotate_towards(current, best);

    //move towards the best midpoint.
    move_forward_live_update(dist, current);
}

// returns one if it needs to run again because still blocked
int hit_move(position *current, coord_t destination)
{
    //used for debug - not needed in final build.
    //char message[100];

    //declare counter variable for later and clear gaps array
    int i;
    memset(gaps, 0, sizeof(gaps));
    gap_number = 0;

    //first, need to rotate the bot so the robot has the destination at the 90 degree point of the scan.
    rotate_towards(current, destination);

    //next, perform a 180 degree scan with the shortest path at the 90 degree point.
    scan_for_objects();

    //if no obstacles are detected, we simply move forward along the easiest path.
    if (num_obstacles == 0)
    {
        move_forward_live_update(dist, current);
        return;
    }
    //if that if failed, then we have to find a new path.
    //now, we should have all of the coordinate points of the edges of objects. with this, we should be able to find potential gaps by doing some fun trig.

    //declare a intermediary coordinate.
    coord_t temp;
    //floats for pythagorean.
    float side_a, side_b, side_c;
    //iterate through all of the gaps. for n obstacles there are n+1 gaps, so use <=.
    for (i = 0; i <= num_obstacles; i += 2)
    {
        //there are special things that we need to do for the first and last object since they are gapped against the scan line.
        if (i == 0)
        {
            //check to see if the start angle is not zero.
            if (objects[num_objects - 1].start_angle != 0)
            {
                //create coordinates for generating the point along the perpendicular line
                coord_t limit;
                coord_t incr;
                //find the x and y increments to get 50 cm away from the bot, perpendicular to the 90 deg scan line.
                incr = get_increments(current, destination);
                //find the current servo position.
                coord_t servo = find_servo_pos(current);
                //find that 50 cm point relative to the servo.
                limit.x = servo.x + incr.x;
                limit.y = servo.y - incr.y;
                //the gap magnitude will be the resultant between the 50 cm extension and the first edge.
                gaps[gap_number].gap = (int) find_resultant(limit,
                                                            obstacles_arr[0]);
                //find the midpoint by getting the x and y differential and dividing by 2.
                temp.x = (int) round(
                        limit.x + (obstacles_arr[0].x - limit.x) / 2.0f);
                temp.y = (int) round(
                        limit.y + (obstacles_arr[0].y - limit.y) / 2.0f);
                //set the midpoint
                gaps[gap_number].midpt.x = temp.x;
                gaps[gap_number].midpt.y = temp.y;

                //debug; not used in final build
                //            sprintf(message, " (%d, %d) \n\r", limit.x, limit.y);
                //            uart_sendStr(message);
            }
        }
        //this case if for when we need to find the gap between the final edge and the 180 degree side extension.
        else if (i == num_obstacles)
        {
            //check to see if the end angle of the object is not 180.
            if (objects[num_objects - 1].end_angle != 180)
            {
                //create coordinates for generating the point along the perpendicular line.
                coord_t limit;
                coord_t incr;
                //find the x and y increments to get 50 cm away from the bot, perpendicular to the 90 deg scan line.
                incr = get_increments(current, destination);
                //find the current servo position.
                coord_t servo = find_servo_pos(current);
                //find that 50 cm point relative to the servo.
                limit.x = servo.x - incr.x;
                limit.y = servo.y + incr.y;
                //the gap magnitude will be the resultant between the 50 cm extension and the first edge.
                gaps[gap_number].gap = (int) find_resultant(
                        limit, obstacles_arr[i - 1]);
                //find the midpoint by getting the x and y differential and dividing by 2.      
                temp.x = (int) round(
                        limit.x + (obstacles_arr[i - 1].x - limit.x) / 2.0f);
                temp.y = (int) round(
                        limit.y + (obstacles_arr[i - 1].y - limit.y) / 2.0f);
                //set the midpoint
                gaps[gap_number].midpt.x = temp.x;
                gaps[gap_number].midpt.y = temp.y;
                //debug; not used in final build
                //            sprintf(message, " (%d, %d) \n\r", limit.x, limit.y);
                //            uart_sendStr(message);
            }
        }
        //this last case is the most frequently used and is for finding gaps between objects.
        else
        {
            //first, find the gap size through pythagorean. side_a is x, side_b is y.
            side_a = obstacles_arr[i - 1].x - obstacles_arr[i].x;
            side_b = obstacles_arr[i - 1].y - obstacles_arr[i].y;
            side_c = (int) round(sqrt(pow(side_a, 2) + pow(side_b, 2)));
            //put in the gap array
            gaps[gap_number].gap = side_c;
            //with the gap size found, need to find the midpoint by getting half of the differential and adding it to the first coordinate.
            temp.x = obstacles_arr[i - 1].x
                    + (obstacles_arr[i].x - obstacles_arr[i - 1].x) / 2.0f;
            temp.y = obstacles_arr[i - 1].y
                    + (obstacles_arr[i].y - obstacles_arr[i - 1].y) / 2.0f;
            gaps[gap_number].midpt = temp;
        }
        //increment the amount of gaps found
        gap_number++;
    }

    //initialize temp coord with current position.
    temp.x = current->x;
    temp.y = current->y;
    //load with a dummy value
    float best_resultant = -1;
    coord_t best;
    float tempf;
    for (i = 0; i < gap_number; i++)
    {
        // this time find the largest resultant because we want the furthest resultant.
        tempf = find_resultant(gaps[i].midpt, destination);
        //if the gap between the current midpoint and destination is greater than the current value, and the gap is sufficient, and it wont drive us out of bounds, then it becomes the best.
        if (tempf > best_resultant)
        {
            if (gaps[i].gap >= 310 && gaps[i].midpt.x > 175
                    && gaps[i].midpt.y > 175 && gaps[i].midpt.x < (GRID_X - 175)
                    && gaps[i].midpt.y < (GRID_Y - 175))
            {
                best_resultant = tempf;
                best.x = gaps[i].midpt.x;
                best.y = gaps[i].midpt.y;
            }

        }
    }

    // find the angle from bot to best
    int angle_to_best = find_angle_to_obstacle_coord(current, best);
    int angle_to_obj = find_angle_to_obstacle_coord(current, destination);
    // only if the best midpoint is not in the area it needs to drive
    int best_is_good = 1;
    if ((angle_to_best < angle_to_obj + 10)
            || (angle_to_best > angle_to_obj - 10))
    {
        best_is_good = 0;
    }

    // no good gaps where found so now rotate same direction, then indicate to scan again by returning 1
    if (best_resultant == -1 && best_is_good == 0)
    {
        prepMarioSound();
        playSong(0);
        int angle_diff = current->deg - current->prev_deg;
        if (angle_diff > 0)
        {
            turn_counterclockwise_live_update(45, current);
        }
        else
        {
            turn_clockwise_live_update(45, current);
        }
        return 1;
    }
    // found somewhere to move to
    // rotate toward destination
    rotate_towards(current, best);
    //move towards
    move_forward_live_update(300, current);
    // return 0 indicates that the move was completed
    return 0;
}

